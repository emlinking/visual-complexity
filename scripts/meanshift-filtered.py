# -*- coding: utf-8 -*-
"""
Functions to conduct mean-shift segmentation followed by region filtering.

Created on Wed Jun 15 14:12:45 2022

@author: linel
"""
import cv2
import matplotlib.pyplot as plt
import numpy as np
import os
import pickle
from PIL import Image
import pymeanshift as pms
import random
import sys
import time

def segment_images(img_dir : str, sp=3, sr=10, min_density=300) -> list:
    """
    Given a directory of images img_dir, segment each image and return a list of tuples 
    (img_name, segmented_image, label_image, number_regions) via pymeanshift.segment()
    
    Parameters:
    img_dir : str - The name of the directory containing images to segment.
    
    sp : int - The size of the spatial window for mean-shift filtering (default: 3).
    
    sr : int - The size of the colorspace window for mean-shift filtering (default: 10).
    
    min_density : int - The minimum number of pixels per region (helps determine which regions to merge after
    running mean-shift filtering).
    
    Returns:
    A list of (img_name, img, label_image, number_regions) tuples generated via pymeanshift.segment().
    Note that segmented image is discarded (img is original, presegmentation
    image.)
    """
    start = time.perf_counter()
    print("Segmenting images from {} . . . ".format(img_dir), end="")
    
    segmented_imgs = []
    img_paths = os.listdir(img_dir)
    
    for i, img_path in enumerate(img_paths):
        if img_path[0] != '.': # avoid picking up hidden files
            img = cv2.imread(os.path.join(img_dir, img_path), cv2.COLOR_BGR2RGB)
            (segmented_image, labels_image, number_regions) = pms.segment(img, sp, sr, min_density)
            segmented_imgs.append((img_path, img, labels_image, number_regions))
        
        if i == (len(img_paths)//2):
            print("Halfway there . . . ", end="")
        
    stop = time.perf_counter()
    print("Done. Total time to segment: {0:.4f} s".format(stop - start))
    
    return segmented_imgs

def show_image(img : np.ndarray, grayscale=False, cbar=False):
    """
    Display single image (rgb or grayscale), optionally with color bar

    Parameters
    ----------
    img : np.ndarray
        image of dimensions (height, width, channels) with channels in order
        rgb
    grayscale : bool, optional
        whether to display image with grayscale color map. The default is False.
    cbar : bool, optional
        whether to display image with color bar (e.g., for plotting labels). 
        The default is False.

    Returns
    -------
    None.

    """
    if grayscale:
        plt.imshow(img, cmap='gray')
    else:
        plt.imshow(img)
    
    plt.axis('off')
    
    if cbar:
        plt.colorbar()
    
    plt.show()

def get_region_size(labels : np.ndarray, region_label : int) -> int:
    """
    Calculate size of region in pixels given labels matrix generated by 
    pymeanshift.
    
    Parameters:
        
    labels : np.ndarray
        Pixelwise mask with region labels for segmented image.
    region_label : int
        Label of region to get size for.
        
    Returns:
        Size of regions in pixels as int
    """
    return np.count_nonzero(np.where(labels == region_label, 1, 0))

def get_size_difference(size1 : int, size2 : int, imsize : int) -> float:
    """
    Calculate differences in sizes of 2 regions as proportion of total image 
    size.
    
    Parameters:
        
    size1 : int
        Number of pixels in region 1
    size2 : int
        Number of pixels in region 2
    imsize : int
        Number of pixels in image
        
    Returns:
        float representing difference in sizes of regions 1 and 2 as proportion
        of total image size
    """
    return abs(size1/imsize - size2/imsize)

def is_similar_sizes(size1 : int, size2: int, imsize : int, 
                     threshold : float) -> bool:
    """
    Determine if two regions are of similar sizes based on threshold that is 
    proportion of total image size.

    Parameters
    ----------
    size1 : int
        size of first region in pixels
    size2 : int
        size of second region in pixels
    imsize : int
        size of image in pixels
    threshold : float
        size difference threshold as proportion of total image size. If 
        difference in sizes of two regions is greater than threshold, return
        False. Otherwise, return True.

    Returns
    -------
    bool
        whether size1 and size2 are similar based on threshold

    """
    return get_size_difference(size1, size2, imsize) <= threshold
    
def get_region_color(img : np.ndarray, labels : np.ndarray, 
                     region_label : int) -> np.ndarray:
    """
    Get mean color of region (average of pixel values by channel from original
    image, using pixel locations from labels matrix).
    
    Parameters:
    
    img : np.ndarray
        Original (presegmentation) image
    labels : np.ndarray
        Matrix with pixelwise region labels, output from pymeanshift.segment
    region_label : int
        Label of region for which to retrieve mean region color
        
    Returns:
        np.ndarray [r,g,b]
    """
    pixels = np.where((labels == region_label)[:, :, np.newaxis], img, -1)
    pixels = pixels.transpose((2, 0, 1))
    r, g, b = pixels[0].flatten(), pixels[1].flatten(), pixels[2].flatten()
    r, g, b = int(r[r >= 0].mean()), int(g[g >= 0].mean()), int(b[b >= 0].mean())
    
    return np.array((r, g, b))
    
def get_color_difference(color1 : np.ndarray, color2 : np.ndarray) -> int:
    """
    Compute (squared) Euclidean color difference.
    
    Parameters:
        
    color1, color2: arrays of (r, g, b) values representing mean colors of regions
    to compare.
    
    Returns:
        Squared Euclidean distance between color1 and color2, computed as
        (r1-r2)^2 + (g1-g2)^2 + (b1-b2)^2.
    
    """
    return np.sum((color1 - color2)**2)

def is_similar_colors(color1 : np.ndarray, color2 : np.ndarray, 
                      threshold : int) -> bool:
    """
    Determine whether color1 and color2 are similar based on threshold.

    Parameters
    ----------
    color1 : np.ndarray
        describes mean color of region 1 as [r,g,b]
    color2 : np.ndarray
        describes mean color of region 2 as [r,g,b]
    threshold : int
        represents squared Euclidean color difference. If difference between
        colors 1 and 2 is greater than threshold, return False. Otherwise,
        return True.

    Returns
    -------
    bool
        whether color1 and color2 are similar based on threshold

    """
    return get_color_difference(color1, color2) <= threshold

def count_distinct_regions(img : np.ndarray, labels_mat : np.ndarray, 
                           cdiff_thresh : int, sdiff_thresh: float) -> dict:
    """
    Count number of distinct regions in mean-shift segmented image.
    Distinct regions defined as those which have dissimilar color and size, 
    as set by cdiff_thresh and sdiff_thresh.
    
    Parameters
    ----------
    img : np.ndarray
        original (presegmentation) image, should be of shape (height, width,
        channels) with channels in RGB order
    labels_mat : np.ndarray
        output from pymeanshift.segment, contains pixelwise region labels for
        segmented img
    cdiff_thresh: int
        represents squared Euclidean color difference. If difference between
        mean colors of regions ompared is greater than threshold, return False. 
        Otherwise, return True.
    sdiff_thresh: float
        difference in sizes of regions compared, as proportion of total image
        size. If difference in sizes > sdiff_thresh, regions sizes are 
        dissimilar.
    Returns
    -------
    dict
        dictionary of distinct regions {region_labels : {size : int, color : 
                                                         np.ndarray}}
    """
    labels = np.unique(labels_mat)
    
    # seed dictionary of distinct regions with first region from labels
    distinct = {labels[0] : {'size' : get_region_size(labels_mat, labels[0]), 
                             'color' : get_region_color(img, labels_mat, 
                                                        labels[0])}}
    
    # for each region, compare to those already in dictionary and decide
    # whether to add based on distinctness of color and size
    for label in labels[1:]:
        size = get_region_size(labels_mat, label)
        color = get_region_color(img, labels_mat, label)
        
        similar_sized = [] # track similarly sized regions
        
        # compare sizes of regions
        for r in distinct:
            if is_similar_sizes(size, distinct[r]['size'], 
                                threshold=sdiff_thresh, imsize=labels_mat.size):
                similar_sized.append(r)
        
        # differently sized regions are automatically counted as distinct
        if len(similar_sized) == 0:
            distinct[label] = {'size' : size, 'color' : color}
        else: # compare colors of similarly sized regions
            for r in similar_sized:
                if is_similar_colors(color, distinct[r]['color'], 
                                     threshold=cdiff_thresh):
                    break
            else: # found no other regions in our set with both similar size AND color
                distinct[label] = {'size' : size, 'color' : color}

    return distinct

def display_filtered_regions(number_regions : int, distinct_reg : dict, 
                             labels_image : np.ndarray) -> None:
    """
    Show labels of distinct regions of segmented image. Useful for evaluating
    success of region filtering algorithm. Distinct regions will show up as
    bright yellow, non-distinct regions as blue.

    Parameters
    ----------
    number_regions : int
        Number of mean-shift segmented regions (output from pymeanshift.segment)
    distinct_reg : dict
        Dictionary of distinct regions filtered from mean-shift segmentation.
        Output from count_distinct_regions.
    labels_image : np.ndarray
        Mask for segmented image indicated which region each pixel belongs to.
        Part of pymeanshift.segment output.
        
    Returns
    -------
    None.

    """
    print('Unfiltered regions:', number_regions)
    print('Number of distinct regions:', len(distinct_reg))

    labels_filtered = labels_image.copy()
    for label in distinct_reg.keys():
        labels_filtered[labels_image == label] = 1000
    
    show_image(labels_filtered)
    
def filter_regions(images : list, cdiff_thresh : int, sdiff_thresh: int) -> list:
    """
    Count distinct regions for a batch of images.
    
    Parameters:
        
    images : list 
        list of (img_path, segmented_image, labels_image, number_regions)
        tuples. Output from segment_images.
    cdiff_thresh: int
        represents squared Euclidean color difference. If difference between
        mean colors of regions ompared is greater than threshold, return False. 
        Otherwise, return True.
    sdiff_thresh: float
        difference in sizes of regions compared, as proportion of total image
        size. If difference in sizes > sdiff_thresh, regions sizes are 
        dissimilar.
        
    Returns:
        list of distinct regions dictionaries for each image in images
    """
    filtered = []
    
    for (img_path, img, labels_image, number_regions) in images:
        distinct = count_distinct_regions(img, labels_image, 
                                          cdiff_thresh, sdiff_thresh)
        filtered.append((img_path, distinct))
        
    return filtered
    
def main(args : list) -> None:
    """
    Calculate complexity scores for images in given directory.
    Outputs files with number of mean-shift segmented regions and number of
    distinct regions printed to consecutive lines, optionally followed by
    'grayscale 2d' if single-channel (grayscale) image is detected.
    Outputs are saved as text files.

    Parameters
    ----------
    args : list
        args[1] : path to directory with images to compute complexity data for
        
        args[2] : output directory to write complexity data to
        
        args[3] : cdiff_thresh
        
        args[4] : sdiff_thresh
    Returns
    -------
    None

    """
    in_dir, out_dir, cdiff_thresh, sdiff_thresh = args[1], args[2], int(args[3]), \
                                                    float(args[4])
    start = time.perf_counter()
    
    imgs = os.listdir(in_dir)
    random.shuffle(imgs)
    
    for img in imgs:
        written = os.listdir(out_dir)
        filename = '{}.txt'.format(img)
        
        if filename not in written:
            with open(os.path.join(out_dir, filename), 'w') as out_f:
                img = np.array(Image.open(os.path.join(in_dir, img)))
                
                (segmented_img, 
                 labels, 
                 number_regions) = pms.segment(img, 3, 10, 300)
                    
                if len(segmented_img.shape) == 3: # rgb image
                    # count distinct regions
                    distinct_regions = count_distinct_regions(img, 
                                                              labels, 
                                                              cdiff_thresh, 
                                                              sdiff_thresh)
                    num_distinct = len(distinct_regions)
                    
                    # save results
                    out_f.write(str(number_regions) + '\n' + str(num_distinct))
                    
                else: # grayscale image
                    img_3d = np.repeat(img[:, :, np.newaxis], 3, axis=2)
                    distinct_regions = count_distinct_regions(img_3d, labels,
                                                              cdiff_thresh, 
                                                              sdiff_thresh)
                    num_distinct = len(distinct_regions)
                    
                    out_f.write(str(number_regions) + '\n' + str(num_distinct)
                                + '\ngrayscale 2d')
    
    stop = time.perf_counter()
    print('Time to compute: {0:.4f}s'.format(stop - start))
    
if __name__ == '__main__':
    main(sys.argv)